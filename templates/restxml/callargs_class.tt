[%- operation = c.operation(op_name) %]
[%- shape = c.input_for_operation(op_name) %]
package [% c.api %]::[% op_name %];
  use Moo;
[%- attr_str = []; attr_types = ['Str']; attr_ind = 0;  class_types = {}; params_hash = {}; -%]
[% FOREACH param_name IN shape.members.keys.sort;
  member = c.shape(shape.members.$param_name.shape);
  attr_str.$attr_ind = "has $param_name => (is => 'ro', isa => ${member.perl_type}";
  IF (c.required_in_shape(shape,param_name));attr_str.$attr_ind = attr_str.$attr_ind _ ", required => 1"; END;
  attr_str.$attr_ind = attr_str.$attr_ind _", predicate => 1);";
  CALL attr_types.import(member.base_types.keys);
  params_hash.types.$param_name = { type => member.perl_type };
  FOREACH k IN member.class_type_info.keys; class_types.$k = member.class_type_info.$k; params_hash.types.$param_name.class = member.class_type_info.$k; END;
  IF (shape.members.${param_name}.location == 'header');
    IF (param_name == 'ContentMD5');  params_hash.AutoInHeader.$param_name = { header_name => shape.members.${param_name}.locationName, auto => 'MD5' }; 
    ELSE; params_hash.ParamInHeader.$param_name = shape.members.${param_name}.locationName;
    END;
  ELSIF (shape.members.$param_name.location == 'headers'); params_hash.ParamInHeaders.$param_name = shape.members.$param_name.locationName;
  ELSIF (shape.members.$param_name.location == 'querystring'); params_hash.ParamInQuery.$param_name = shape.members.$param_name.locationName;
  ELSIF (shape.members.$param_name.location == 'uri'); params_hash.ParamInURI.$param_name = shape.members.$param_name.locationName;
  ELSIF (shape.members.$param_name.streaming == 1); stream_param = param_name; params_hash.ParamsInBody.push(param_name);
  ELSE;
    IF (shape.members.$param_name.locationName != '');
      IF (shape.members.$param_name.locationName == 'x-amz-meta-');
      ELSIF (shape.members.$param_name.locationName != param_name); params_hash.NameInRequest.$param_name = shape.members.$param_name.locationName;
      END;
    END;
  END;
  SET attr_ind = attr_ind + 1;
END; %]
  use Types::Standard qw/[% attr_types.unique.join(" ") %]/;
  use [% c.typelibrary_name %] qw/[% class_types.keys.join(" ") %]/;
[% FOREACH attr IN attr_str -%]
  [% attr %]
[% END -%]

use MooX::ClassAttribute;

  class_has _api_call => (isa => Str, is => 'ro', default => '[% op_name %]');
  class_has _api_uri  => (isa => Str, is => 'ro', default => '[% operation.http.requestUri %]');
  class_has _api_method  => (isa => Str, is => 'ro', default => '[% operation.http.method %]');
  class_has _returns => (isa => Str, is => 'ro', default => '
    [%- IF (operation.output.keys.size) -%]
      [%- c.api %]::[% c.shapename_for_operation_output(op_name) -%]
    [%- ELSE -%]Paws::API::Response[% END -%]');
  class_has _result_key => (isa => Str, is => 'ro');
  [% IF (stream_param) %]class_has _stream_param => (is => 'ro', default => '[% c.to_payload_shape_name(stream_param) %]');[% END %]
  [% PROCESS params_map.tt %]
1;

[% INCLUDE 'callclass_documentation.tt' %]
